# 随机梯度下降

三种梯度下降：

Gradient Descent(GD)、SGD(stochastic gradient descent)、MB GD(mini batch gradient descent)

三者的区别，gradient descent是一个epoch以后，过完一遍训练集以后根据所有样本的损失函数大小来优化权重，容易陷入局部最优。

SGD是每个样本更新一次权重，MB GD是结合了GD和SGD，也就是每次根据一个batch来更新权重，能够达到局部最优值，同时加快了收敛。

参考[链接](https://www.quora.com/Whats-the-difference-between-gradient-descent-and-stochastic-gradient-descent)。

# 随机森林random forest

随机森林的概率是如何计算出来的？

某个观察值x在k类别下的概率分布密度函数，$f(x)=\sum_{k}\pi_{k}f_{k}(x)$

其中$\sum_{k=1}^{K}\pi_{k}=1$并且$0\leq\pi_{k}\leq1$

给定观察值x，标签为k的概率是 $\dfrac{P(Y=k|x=X_{new})}{f(x)}$

也就是给定x和标签为k，有个当下的概率，占概率分布密度函数总和的百分比。

# random forest与GBDT的基分类器的区别

Random forest的基分类器即有分类树也有回归树，GBDT的基分类器是回归树。

# 决策树

决策树遍历一个数据的相关特征，最终得出关于这个数据点的预测值（如果是离散的就是分类，连续的就是回归）。决策树的每个节点都是一个特征，而叶子节点就是该对象的预测值。

![Three different representations of a regression tree of kyphosis data](http://upload-images.jianshu.io/upload_images/2338511-bf652f2035829a41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

决策树每个根节点都是对应的标签和概率，上图当中可以这么看，先是划分的特征是start，标准以是否start>=8.5，因此对应维度8.5横向划一刀，以上的是一类，以下还得继续分割；接下来在8.5以上继续寻找分割点，这一次是start是否大于14，如果大于14了，就是绿点，有个概率；小于14了，接着划分，这个时候分割特征就不是start了，是纵向维度的age，如果是大于9.2，则直接是绿点，有概率；如果是小于9.2，则还要看下一个分割点，是否小于4.6，如果大于4.6且小于9.2，那么就直接是红点；如果是小于4.6，那么分配绿点，仍旧是有概率。

决策树有两种：分类树和回归树，CART是一个涵盖性术语，包含了两种。

## 集成方法

集成方法是用了多棵树做决策。有两种：一种是boosted trees，另外一种是bootstrap aggregated trees。两种的区别是，前者是通过不断减小被错误划分的训练对象来构建模型的方法，一个特例就是adaboost，可以用来分类和预测。

boostrap是随机抽取样本，随机抽取特征，构建多棵决策树，最后投票做预测。

### 决策树的节点

是一个对特征值的测试

### 决策树的枝干

测试的结果（是否大于某个值还是小于某个值）

### 决策树的叶子节点

带有标签

## 多种决策树模型

- ID3
- C4.5
- CART

决策树从上往下构建，在每个分割点的划分标准是最好将集合分开的划分节点。而这个“好坏”的标准决定了不同的决策树。

常见的指标有Gini Impurity用于CART的分类树，信息增益Information gain用于ID3和C4.5，以及方差减少variance reduction用于CART的回归树（也就是连续值问题）。

### Gini不纯度

$IG=1-\sum_{i=1}^{J}p_{i}$其中$p_{i}$是标签为i的在集合中被正确标记的第i个的概率，代表的是子集当中，如果标签为i的是随机被标记的，会有多少被标记为错误的。

### 信息增益

信息增益是指父节点和子节点的熵的差。

熵的表达式$H(T)=-\sum_{i=1}^{J}pi*log(pi)$

信息增益$IG(T, a)=H(T)-H(T|a)$

### 方差减少量

# 支持向量机

支持向量机目的是找到一个决策平面，能够最大化离两种类别的最近的点的间隔最大化，这样当一个新的数据点进行来的时候，我们能够最有信心地预测该数据点所在的类别。

### 支持向量机的特征映射

有一些使用场景下，数据点并不是线性可分的，这个情况下，需要将数据点映射到更高的维度，而在更高维度下超平面是根据映射以后的数据点的点积所决定的。为了在高维度下的点积的计算变得可能，根据我们选用的核函数$k(x,y)$，可以在原本维度上计算出映射以后的点积。

# 主成分分析

主成分分析是指这样一个统计学过程，将一组可能相关的变量经过正交变换转变为非相关的变量（主成分）。

PCA能够获得最能够解释数据变异性最大的方向，因此可以获得对数据内部结构的认识。PCA获得高维度空间上多个向量在低维度上面的投影，能够减少维度。









# 偏差与方差

# 什么是bootstrap



# 最大似然估计

假设我们的一些样本的分布是基于某些参数的，比如正态分布是基于$x~N(\mu,\sigma)$，那么我们希望通过样本来找出总体的这些参数的估计值，比如$\mu$和$\sigma$，称为最大似然分布。我们希望能够从样本当中获得估计的参数，或者估计函数，最大化概率或者是最像我们观察值获得获得总体的数据分布。找到一个参数值能够最大化联合分布概率密度函数。

最大似然估计就是找出模型的参数，给定假设的模型之后，还要确定参数，这样才能够确定一个实体的分布，而带有这些参数的模型能够最大近似地描绘出产生我们观察到的点的过程，这个过程也是概率性的。接下来我们需要计算联合概率分布，联合概率分布就是数据点同时出现的概率，是参数的函数，我们只需要最大化这个函数，求出对应的$\mu$和$\sigma$。我们假设每个点的出现都是随机的，那么联合概率jiu

# ADaboosting

adaboosting也是多棵树的组合，共同决策。但不同的是下一层的树会调整上一棵树分错的的样本的权重，得到新的样本分布，降低分对的样本的权重，重点去训练那些分错的样本，对于回归则是去拟合上一棵树预测的样本的残差。

# SVM

## SVM的核函数

SVM的核函数有四种：

- linear线性核函数
- polynomial多项式核函数-------
- Gaussian核函数（RBF）-----样本和特征都少
- Sigmoid核函数

## 软间隔

除了要最大化间隔以外，我们希望能够同时容忍一部分的噪声和误差。因此我们引入误差项，构成了软间隔SVM要优化的目标函数

$\min_{a,b,\xi}\frac{1}{2}\omega\cdot\omega^{T}+C\sum_{i=1}^{n}\xi_{i};s.t\ y_{i}(\omega^{T}\phi(x)+b)>1-\xi_{i}, i=0, 1, 2……$

其中$\xi_{i}$是误差项，该式子意味着要最大化间隔的同时要最小化误差项，C是用户自定义的系数，C越大，说明对误差项的惩罚越大，也就是越不能容忍误差；C越小，能够容忍的误差就越大，也就有越多的点会落在margin内。

## SVM的推导



## 

# 生成模型和判别模型的区别

生成模型和判别模型的区别是，是否先计算联合概率分布？

判别模型是根据数据的信号，直接得出样本属于哪个类别，不计算联合概率。

生成模型先计算联合概率分布之后再根据贝叶斯原理计算条件概率，再计算出该信号对应的概率，来判别所属的类别，也即是考虑信号是如何出现的

# 损失函数

交叉熵binary_crossentropy和多分类交叉熵categorical_crossentropy

真实的观察值的概率分别是：$P_{y=1}=y$和$P_{y=0}=1-y$

预测值的概率表示：$Q_{\hat y=1}=\hat y$和$Q_{\hat y=0}=1-\hat y$



交叉熵函数的计算公式：

$H(p, q)=-\sum_{i=1}^{N}p_{i}log\ q_{i}=-ylog\ \hat y-(1-y)log\ (1-\hat y)$

交叉熵衡量两个分布p和q的不一致程度。

损失函数J(W)是所有交叉熵的平均值

$J(W)=\frac{1}{N}\sum_{n=1}^{N}H(p_{n},q_{n})=-\frac{1}{N}\sum_{n=1}^{N}(y_{n}log\ \hat y_{n}+(1-y_{n})log\ (1-\hat y_{n}))$



# 激活函数

## softmax激活函数

softmax激活函数能够将k维的向量z映射成一个k维的向量$\sigma(z)$，映射后每个元素都在(0,1)之间，并且元素之和为1

公式，是逻辑函数的推广。给定一个样本x，它为j类别的可能性的大小：

$P(y=j|X)=\frac{e^{X^{T}\omega_{j}}}{\sum_{k=1}^{K}e^{X^{T}\omega_{k}}}$

代码实现：

![softmax代码实现](https://upload-images.jianshu.io/upload_images/2338511-0ebc5fcac225d741.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


# word2vec的实现原理

